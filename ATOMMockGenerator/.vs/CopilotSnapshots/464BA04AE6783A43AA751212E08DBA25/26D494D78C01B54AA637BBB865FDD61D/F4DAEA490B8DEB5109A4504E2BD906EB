using ATOMMockGenerator.Server.Models;
using System.Collections.Concurrent;

namespace ATOMMockGenerator.Server.Services
{
    public interface IMappingService
    {
        Task<List<WiremockMapping>> GetAllMappingsAsync();
        Task<WiremockMapping?> GetMappingAsync(string id);
        Task<WiremockMapping> CreateMappingAsync(WiremockMapping mapping);
        Task<WiremockMapping> UpdateMappingAsync(string id, WiremockMapping mapping);
        Task<bool> DeleteMappingAsync(string id);
        Task<List<WiremockMapping>> GenerateMappingsAsync(JsonConfig config);
        Task<byte[]> ExportMappingsAsync(List<string> mappingIds);
    }

    public class MappingService : IMappingService
    {
        // In-memory storage for demo purposes
        // In a real application, you would use a database or external API
        private readonly ConcurrentDictionary<string, WiremockMapping> _mappings = new();

        public Task<List<WiremockMapping>> GetAllMappingsAsync()
        {
            return Task.FromResult(_mappings.Values.ToList());
        }

        public Task<WiremockMapping?> GetMappingAsync(string id)
        {
            _mappings.TryGetValue(id, out var mapping);
            return Task.FromResult(mapping);
        }

        public Task<WiremockMapping> CreateMappingAsync(WiremockMapping mapping)
        {
            mapping.Id = Guid.NewGuid().ToString();
            _mappings[mapping.Id] = mapping;
            return Task.FromResult(mapping);
        }

        public Task<WiremockMapping> UpdateMappingAsync(string id, WiremockMapping mapping)
        {
            mapping.Id = id;
            _mappings[id] = mapping;
            return Task.FromResult(mapping);
        }

        public Task<bool> DeleteMappingAsync(string id)
        {
            return Task.FromResult(_mappings.TryRemove(id, out _));
        }

        public async Task<List<WiremockMapping>> GenerateMappingsAsync(JsonConfig config)
        {
            var generatedMappings = new List<WiremockMapping>();

            foreach (var mapping in config.Mappings)
            {
                // Ensure mapping has an ID
                if (string.IsNullOrWhiteSpace(mapping.Id))
                {
                    mapping.Id = Guid.NewGuid().ToString();
                }

                // Store the mapping
                await CreateMappingAsync(mapping);
                generatedMappings.Add(mapping);
            }

            return generatedMappings;
        }

        public Task<byte[]> ExportMappingsAsync(List<string> mappingIds)
        {
            // In a real implementation, you would create a ZIP file with JSON files
            // For now, we'll return a simple JSON array
            var mappings = mappingIds
                .Select(id => _mappings.TryGetValue(id, out var mapping) ? mapping : null)
                .Where(m => m != null)
                .ToList();

            var json = System.Text.Json.JsonSerializer.Serialize(mappings, new System.Text.Json.JsonSerializerOptions
            {
                WriteIndented = true
            });

            return Task.FromResult(System.Text.Encoding.UTF8.GetBytes(json));
        }
    }
}